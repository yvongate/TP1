================================================================================
                    RÉSUMÉ DES CLASSES JAVA DU PROJET
                        Repertoire UICI
================================================================================

Ce document explique comment chaque fichier Java est écrit et comment il fonctionne.

================================================================================
1. Contact.java - MODÈLE DE DONNÉES
================================================================================

RÔLE:
-----
Cette classe représente un contact. C'est le modèle de données qui contient
toutes les informations d'un contact (nom, téléphone, email, etc.).

IMPORTS UTILISÉS:
-----------------
import android.os.Parcel;
import android.os.Parcelable;

→ Parcel et Parcelable permettent de passer des objets Contact entre les
  différentes activités Android.

STRUCTURE DE LA CLASSE:
-----------------------
public class Contact implements Parcelable {

ATTRIBUTS (Variables de la classe):
-----------------------------------
private String id;              // Identifiant unique du contact
private String nom;             // Nom de famille
private String prenoms;         // Prénoms
private String email;           // Adresse email
private String telephone;       // Numéro de téléphone
private String lieuHabitation;  // Lieu d'habitation
private String lienMap;         // Lien Google Maps

→ Tous les attributs sont "private" = on ne peut pas y accéder directement
  de l'extérieur. On doit passer par des méthodes (getters).

CONSTRUCTEUR:
-------------
public Contact(String id, String nom, String prenoms, String email,
               String telephone, String lieuHabitation, String lienMap) {
    this.id = id;
    this.nom = nom;
    this.prenoms = prenoms;
    this.email = email;
    this.telephone = telephone;
    this.lieuHabitation = lieuHabitation;
    this.lienMap = lienMap;
}

→ Le constructeur permet de créer un nouveau contact en lui donnant
  toutes ses informations.
→ "this." fait référence à l'attribut de la classe (pour le différencier
  du paramètre qui a le même nom).

GETTERS (Méthodes pour récupérer les valeurs):
-----------------------------------------------
public String getId() { return id; }
public String getNom() { return nom; }
public String getPrenoms() { return prenoms; }
public String getEmail() { return email; }
public String getTelephone() { return telephone; }
public String getLieuHabitation() { return lieuHabitation; }
public String getLienMap() { return lienMap; }

→ Ces méthodes permettent de lire les valeurs des attributs privés.
→ Exemple d'utilisation: contact.getNom() retourne le nom du contact.

MÉTHODES PARCELABLE (pour passer l'objet entre activités):
-----------------------------------------------------------
protected Contact(Parcel in) {
    id = in.readString();
    nom = in.readString();
    prenoms = in.readString();
    email = in.readString();
    telephone = in.readString();
    lieuHabitation = in.readString();
    lienMap = in.readString();
}

→ Constructeur qui reconstruit un Contact à partir d'un Parcel.

public void writeToParcel(Parcel dest, int flags) {
    dest.writeString(id);
    dest.writeString(nom);
    dest.writeString(prenoms);
    dest.writeString(email);
    dest.writeString(telephone);
    dest.writeString(lieuHabitation);
    dest.writeString(lienMap);
}

→ Méthode qui écrit le Contact dans un Parcel pour le transférer.

COMMENT ÇA MARCHE:
------------------
1. On crée un nouveau contact avec "new Contact(...)"
2. On peut lire ses propriétés avec les getters: contact.getNom()
3. On peut le passer entre activités grâce à Parcelable
4. On peut le sauvegarder en JSON grâce à Gson


================================================================================
2. ContactManager.java - GESTIONNAIRE DE PERSISTANCE
================================================================================

RÔLE:
-----
Cette classe gère la sauvegarde et la récupération des contacts. Elle utilise
SharedPreferences pour stocker les données de manière persistante.

IMPORTS UTILISÉS:
-----------------
import android.content.Context;
import android.content.SharedPreferences;
import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;

→ Context: permet d'accéder aux ressources Android
→ SharedPreferences: système de stockage clé-valeur d'Android
→ Gson: bibliothèque pour convertir des objets Java en JSON et vice-versa
→ TypeToken: permet de spécifier le type exact lors de la conversion JSON

STRUCTURE DE LA CLASSE:
-----------------------
public class ContactManager {

ATTRIBUTS:
----------
private SharedPreferences sharedPreferences;
private Gson gson;

→ sharedPreferences: où on stocke les données
→ gson: outil pour convertir les contacts en JSON

CONSTRUCTEUR:
-------------
public ContactManager(Context context) {
    this.sharedPreferences = context.getSharedPreferences("contacts_prefs",
                                                          Context.MODE_PRIVATE);
    this.gson = new Gson();
}

→ Crée un fichier de stockage appelé "contacts_prefs"
→ MODE_PRIVATE = seule notre app peut y accéder
→ Initialise Gson pour la conversion JSON

MÉTHODE: saveContacts (Sauvegarder la liste complète)
------------------------------------------------------
public void saveContacts(List<Contact> contacts) {
    String json = gson.toJson(contacts);
    sharedPreferences.edit().putString("contacts", json).apply();
}

COMMENT ÇA MARCHE:
1. gson.toJson(contacts) → Convertit la liste de contacts en texte JSON
2. sharedPreferences.edit() → Ouvre le mode édition
3. putString("contacts", json) → Enregistre le JSON sous la clé "contacts"
4. apply() → Sauvegarde les modifications

MÉTHODE: getContacts (Récupérer tous les contacts)
---------------------------------------------------
public List<Contact> getContacts() {
    String json = sharedPreferences.getString("contacts", null);
    if (json != null) {
        Type type = new TypeToken<ArrayList<Contact>>() {}.getType();
        return gson.fromJson(json, type);
    } else {
        return new ArrayList<>();
    }
}

COMMENT ÇA MARCHE:
1. Récupère le JSON stocké (ou null si rien n'existe)
2. Si du JSON existe:
   - TypeToken indique qu'on veut une ArrayList<Contact>
   - gson.fromJson convertit le JSON en liste de contacts
3. Sinon: retourne une liste vide

MÉTHODE: addContact (Ajouter un contact)
-----------------------------------------
public void addContact(Contact contact) {
    List<Contact> contacts = getContacts();
    contacts.add(contact);
    saveContacts(contacts);
}

COMMENT ÇA MARCHE:
1. Récupère la liste actuelle de contacts
2. Ajoute le nouveau contact à la liste
3. Sauvegarde la liste complète mise à jour

MÉTHODE: deleteContact (Supprimer un contact)
----------------------------------------------
public void deleteContact(String contactId) {
    List<Contact> contacts = getContacts();
    contacts.removeIf(contact -> contact.getId().equals(contactId));
    saveContacts(contacts);
}

COMMENT ÇA MARCHE:
1. Récupère la liste de contacts
2. removeIf() supprime tous les contacts dont l'ID correspond
   (syntaxe lambda: contact -> condition)
3. Sauvegarde la liste mise à jour


================================================================================
3. ContactAdapter.java - ADAPTATEUR RECYCLERVIEW
================================================================================

RÔLE:
-----
Cette classe fait le lien entre les données (liste de contacts) et l'affichage
dans la RecyclerView. Elle crée une carte visuelle pour chaque contact.

IMPORTS UTILISÉS:
-----------------
import android.view.LayoutInflater;
import android.view.ViewGroup;
import androidx.recyclerview.widget.RecyclerView;
import com.uici.repertoire.databinding.ItemContactBinding;

→ RecyclerView: pour l'affichage de listes optimisé
→ ViewBinding: pour accéder facilement aux éléments du layout

STRUCTURE DE LA CLASSE:
-----------------------
public class ContactAdapter extends RecyclerView.Adapter<ContactAdapter.ContactViewHolder>

→ Hérite de RecyclerView.Adapter
→ Utilise ContactViewHolder comme type de ViewHolder

INTERFACE (pour gérer les clics):
----------------------------------
public interface OnContactActionListener {
    void onCallClick(Contact contact);
    void onSmsClick(Contact contact);
    void onLocationClick(Contact contact);
    void onDeleteClick(Contact contact);
}

→ Interface qui définit les actions possibles sur un contact
→ L'Activity qui utilise l'adaptateur doit implémenter cette interface

ATTRIBUTS:
----------
private List<Contact> contacts;
private OnContactActionListener listener;

→ contacts: la liste des contacts à afficher
→ listener: qui écoute les clics sur les boutons

CONSTRUCTEUR:
-------------
public ContactAdapter(List<Contact> contacts, OnContactActionListener listener) {
    this.contacts = contacts;
    this.listener = listener;
}

MÉTHODE: onCreateViewHolder (Créer une vue pour un contact)
------------------------------------------------------------
public ContactViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
    ItemContactBinding binding = ItemContactBinding.inflate(
        LayoutInflater.from(parent.getContext()),
        parent,
        false
    );
    return new ContactViewHolder(binding);
}

COMMENT ÇA MARCHE:
→ Appelée quand RecyclerView a besoin d'une nouvelle carte
→ Inflate (gonfle) le layout item_contact.xml
→ Crée un ViewHolder avec ce layout
→ Retourne le ViewHolder créé

MÉTHODE: onBindViewHolder (Remplir la vue avec les données)
------------------------------------------------------------
public void onBindViewHolder(ContactViewHolder holder, int position) {
    holder.bind(contacts.get(position));
}

COMMENT ÇA MARCHE:
→ Appelée pour chaque contact à afficher
→ position = position du contact dans la liste
→ Appelle bind() du ViewHolder pour remplir les données

MÉTHODE: getItemCount (Nombre d'éléments)
------------------------------------------
public int getItemCount() {
    return contacts.size();
}

→ Retourne le nombre total de contacts à afficher

CLASSE INTERNE: ContactViewHolder
----------------------------------
class ContactViewHolder extends RecyclerView.ViewHolder {
    private ItemContactBinding binding;

    public ContactViewHolder(ItemContactBinding binding) {
        super(binding.getRoot());
        this.binding = binding;
    }

    public void bind(Contact contact) {
        binding.textViewName.setText(contact.getNom() + " " + contact.getPrenoms());
        binding.textViewPhone.setText(contact.getTelephone());

        String email = contact.getEmail().isEmpty() ? "Pas d'email" : contact.getEmail();
        binding.textViewEmail.setText(email);

        String location = contact.getLieuHabitation().isEmpty() ?
                         "Pas de localisation" : contact.getLieuHabitation();
        binding.textViewLocation.setText(location);

        binding.imageButtonCall.setOnClickListener(v -> listener.onCallClick(contact));
        binding.imageButtonSms.setOnClickListener(v -> listener.onSmsClick(contact));
        binding.imageButtonLocation.setOnClickListener(v -> listener.onLocationClick(contact));
        binding.imageButtonDelete.setOnClickListener(v -> listener.onDeleteClick(contact));
    }
}

COMMENT ÇA MARCHE:
→ bind() remplit tous les TextViews avec les infos du contact
→ Opérateur ternaire: condition ? siVrai : siFaux
→ setOnClickListener avec lambda: v -> action
→ Quand on clique sur un bouton, appelle la méthode correspondante du listener


================================================================================
4. SplashActivity.java - ÉCRAN DE DÉMARRAGE
================================================================================

RÔLE:
-----
Affiche le logo de l'application pendant 3 secondes au démarrage, puis
passe automatiquement à l'écran principal.

IMPORTS UTILISÉS:
-----------------
import android.content.Intent;
import android.os.Bundle;
import android.os.Handler;
import android.os.Looper;
import androidx.appcompat.app.AppCompatActivity;

→ Intent: pour naviguer entre les activités
→ Handler: pour exécuter du code après un délai
→ Looper: pour la boucle de messages du thread principal

STRUCTURE:
----------
public class SplashActivity extends AppCompatActivity {

→ Hérite de AppCompatActivity (toutes les activités héritent de ça)

ATTRIBUT:
---------
private static final long SPLASH_DURATION = 3000L;

→ Durée d'affichage: 3000 millisecondes = 3 secondes
→ "final" = constante, ne peut pas être modifiée
→ "L" à la fin = nombre de type long

MÉTHODE: onCreate (Appelée au démarrage de l'activité)
-------------------------------------------------------
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_splash);

    new Handler(Looper.getMainLooper()).postDelayed(() -> {
        startActivity(new Intent(this, MainActivity.class));
        finish();
    }, SPLASH_DURATION);
}

COMMENT ÇA MARCHE:
1. super.onCreate() → Appelle le onCreate de la classe parent
2. setContentView() → Charge le layout activity_splash.xml
3. new Handler(Looper.getMainLooper()) → Crée un gestionnaire sur le thread principal
4. postDelayed(() -> {...}, 3000) → Exécute le code après 3000ms
5. Lambda () -> {...} = code à exécuter après le délai
6. startActivity(new Intent(...)) → Lance MainActivity
7. finish() → Ferme SplashActivity (pour qu'on ne puisse pas revenir avec retour)


================================================================================
5. MainActivity.java - ÉCRAN PRINCIPAL
================================================================================

RÔLE:
-----
Écran principal qui affiche la liste de tous les contacts et gère les actions
(appeler, SMS, localisation, supprimer).

IMPORTS PRINCIPAUX:
-------------------
import android.Manifest;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.net.Uri;
import android.widget.Toast;
import androidx.appcompat.app.AlertDialog;
import androidx.core.app.ActivityCompat;
import androidx.core.content.ContextCompat;
import androidx.recyclerview.widget.LinearLayoutManager;
import com.uici.repertoire.databinding.ActivityMainBinding;

STRUCTURE:
----------
public class MainActivity extends AppCompatActivity
       implements ContactAdapter.OnContactActionListener {

→ Implémente l'interface OnContactActionListener
→ Doit donc définir les 4 méthodes: onCallClick, onSmsClick, onLocationClick, onDeleteClick

ATTRIBUTS:
----------
private ActivityMainBinding binding;
private ContactManager contactManager;
private ContactAdapter contactAdapter;
private List<Contact> contacts;

private static final int REQUEST_CALL_PERMISSION = 1;
private static final int REQUEST_SMS_PERMISSION = 2;

→ binding: pour accéder aux vues du layout
→ contactManager: pour gérer les contacts
→ contactAdapter: pour afficher les contacts
→ contacts: liste des contacts
→ Constantes pour identifier les demandes de permission

MÉTHODE: onCreate
-----------------
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    binding = ActivityMainBinding.inflate(getLayoutInflater());
    setContentView(binding.getRoot());

    contactManager = new ContactManager(this);
    loadContacts();

    setupRecyclerView();
    setupFab();
}

COMMENT ÇA MARCHE:
1. Crée le binding pour accéder aux vues
2. Définit le layout de l'activité
3. Crée le gestionnaire de contacts
4. Charge les contacts depuis le stockage
5. Configure la RecyclerView
6. Configure le bouton flottant d'ajout

MÉTHODE: onResume
-----------------
protected void onResume() {
    super.onResume();
    loadContacts();
}

→ Appelée quand l'activité redevient visible
→ Recharge les contacts (utile après avoir ajouté un nouveau contact)

MÉTHODE: setupRecyclerView
---------------------------
private void setupRecyclerView() {
    contactAdapter = new ContactAdapter(contacts, this);
    binding.recyclerViewContacts.setLayoutManager(new LinearLayoutManager(this));
    binding.recyclerViewContacts.setAdapter(contactAdapter);
}

COMMENT ÇA MARCHE:
1. Crée l'adaptateur avec la liste de contacts et "this" comme listener
2. Définit le LayoutManager (LinearLayout = liste verticale)
3. Attache l'adaptateur à la RecyclerView

MÉTHODE: setupFab (Bouton flottant)
------------------------------------
private void setupFab() {
    binding.fabAddContact.setOnClickListener(v -> {
        startActivity(new Intent(this, AddContactActivity.class));
    });
}

→ Quand on clique sur le FAB, ouvre AddContactActivity

MÉTHODE: loadContacts
----------------------
private void loadContacts() {
    contacts.clear();
    contacts.addAll(contactManager.getContacts());
    if (contactAdapter != null) {
        contactAdapter.notifyDataSetChanged();
    }
    updateEmptyState();
}

COMMENT ÇA MARCHE:
1. Vide la liste actuelle
2. Ajoute tous les contacts du stockage
3. Notifie l'adaptateur que les données ont changé (pour rafraîchir l'affichage)
4. Met à jour l'affichage "aucun contact" si la liste est vide

MÉTHODE: updateEmptyState
--------------------------
private void updateEmptyState() {
    if (contacts.isEmpty()) {
        binding.textViewEmpty.setVisibility(View.VISIBLE);
        binding.recyclerViewContacts.setVisibility(View.GONE);
    } else {
        binding.textViewEmpty.setVisibility(View.GONE);
        binding.recyclerViewContacts.setVisibility(View.VISIBLE);
    }
}

→ Affiche le message "Aucun contact" si la liste est vide
→ Sinon affiche la RecyclerView

MÉTHODE: onCallClick (Appeler un contact)
------------------------------------------
public void onCallClick(Contact contact) {
    if (ContextCompat.checkSelfPermission(this, Manifest.permission.CALL_PHONE)
            != PackageManager.PERMISSION_GRANTED) {
        ActivityCompat.requestPermissions(
            this,
            new String[]{Manifest.permission.CALL_PHONE},
            REQUEST_CALL_PERMISSION
        );
    } else {
        Intent intent = new Intent(Intent.ACTION_CALL);
        intent.setData(Uri.parse("tel:" + contact.getTelephone()));
        startActivity(intent);
    }
}

COMMENT ÇA MARCHE:
1. Vérifie si on a la permission CALL_PHONE
2. Si non: demande la permission
3. Si oui: crée un Intent ACTION_CALL avec le numéro
4. Lance l'application téléphone

MÉTHODE: onSmsClick (Envoyer un SMS)
-------------------------------------
public void onSmsClick(Contact contact) {
    if (ContextCompat.checkSelfPermission(this, Manifest.permission.SEND_SMS)
            != PackageManager.PERMISSION_GRANTED) {
        ActivityCompat.requestPermissions(
            this,
            new String[]{Manifest.permission.SEND_SMS},
            REQUEST_SMS_PERMISSION
        );
    } else {
        Intent intent = new Intent(Intent.ACTION_SENDTO);
        intent.setData(Uri.parse("smsto:" + contact.getTelephone()));
        startActivity(intent);
    }
}

→ Même logique que onCallClick mais pour les SMS
→ ACTION_SENDTO avec "smsto:" ouvre l'app de messagerie

MÉTHODE: onLocationClick (Voir la localisation)
------------------------------------------------
public void onLocationClick(Contact contact) {
    String lienMap = contact.getLienMap();
    if (lienMap != null && !lienMap.isEmpty()) {
        Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(lienMap));
        if (intent.resolveActivity(getPackageManager()) != null) {
            startActivity(intent);
        } else {
            Toast.makeText(this, "Impossible d'ouvrir le lien",
                          Toast.LENGTH_SHORT).show();
        }
    } else {
        Toast.makeText(this, "Localisation non disponible",
                      Toast.LENGTH_SHORT).show();
    }
}

COMMENT ÇA MARCHE:
1. Récupère le lien Maps du contact
2. Si le lien existe et n'est pas vide:
   - Crée un Intent ACTION_VIEW avec le lien
   - Vérifie qu'une app peut gérer ce lien
   - Lance l'app (Google Maps ou navigateur)
3. Sinon: affiche un message Toast

MÉTHODE: onDeleteClick (Supprimer un contact)
----------------------------------------------
public void onDeleteClick(Contact contact) {
    new AlertDialog.Builder(this)
        .setTitle("Supprimer le contact")
        .setMessage("Voulez-vous vraiment supprimer " + contact.getNom() +
                   " " + contact.getPrenoms() + " ?")
        .setPositiveButton("Oui", (dialog, which) -> {
            contactManager.deleteContact(contact.getId());
            loadContacts();
            Toast.makeText(this, "Contact supprimé", Toast.LENGTH_SHORT).show();
        })
        .setNegativeButton("Non", null)
        .show();
}

COMMENT ÇA MARCHE:
1. Crée une boîte de dialogue de confirmation
2. Si l'utilisateur clique "Oui" (lambda):
   - Supprime le contact via le ContactManager
   - Recharge la liste
   - Affiche un Toast de confirmation
3. Si "Non": ne fait rien (null)

MÉTHODE: onRequestPermissionsResult (Réponse aux demandes de permission)
-------------------------------------------------------------------------
public void onRequestPermissionsResult(int requestCode, String[] permissions,
                                      int[] grantResults) {
    super.onRequestPermissionsResult(requestCode, permissions, grantResults);
    switch (requestCode) {
        case REQUEST_CALL_PERMISSION:
        case REQUEST_SMS_PERMISSION:
            if (grantResults.length > 0 &&
                grantResults[0] == PackageManager.PERMISSION_GRANTED) {
                Toast.makeText(this, "Permission accordée",
                             Toast.LENGTH_SHORT).show();
            } else {
                Toast.makeText(this, "Permission refusée",
                             Toast.LENGTH_SHORT).show();
            }
            break;
    }
}

→ Appelée quand l'utilisateur répond à une demande de permission
→ Affiche un message selon que la permission a été accordée ou refusée


================================================================================
6. AddContactActivity.java - AJOUT DE CONTACT
================================================================================

RÔLE:
-----
Écran qui permet d'ajouter un nouveau contact via un formulaire.

IMPORTS PRINCIPAUX:
-------------------
import android.os.Bundle;
import android.util.Patterns;
import android.widget.Toast;
import androidx.appcompat.app.AppCompatActivity;
import com.uici.repertoire.databinding.ActivityAddContactBinding;
import java.util.UUID;

→ Patterns: pour valider le format des emails
→ UUID: pour générer des identifiants uniques

ATTRIBUTS:
----------
private ActivityAddContactBinding binding;
private ContactManager contactManager;

MÉTHODE: onCreate
-----------------
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    binding = ActivityAddContactBinding.inflate(getLayoutInflater());
    setContentView(binding.getRoot());

    if (getSupportActionBar() != null) {
        getSupportActionBar().setDisplayHomeAsUpEnabled(true);
        getSupportActionBar().setTitle("Nouveau Contact");
    }

    contactManager = new ContactManager(this);

    binding.buttonSave.setOnClickListener(v -> saveContact());
    binding.buttonCancel.setOnClickListener(v -> finish());
}

COMMENT ÇA MARCHE:
1. Crée le binding
2. Active le bouton retour dans l'ActionBar
3. Change le titre de l'écran
4. Crée le ContactManager
5. Configure les boutons Enregistrer et Annuler

MÉTHODE: saveContact (Enregistrer le contact)
----------------------------------------------
private void saveContact() {
    String nom = binding.editTextNom.getText().toString().trim();
    String prenoms = binding.editTextPrenoms.getText().toString().trim();
    String email = binding.editTextEmail.getText().toString().trim();
    String telephone = binding.editTextTelephone.getText().toString().trim();
    String lieuHabitation = binding.editTextLieuHabitation.getText().toString().trim();
    String lienMap = binding.editTextLienMap.getText().toString().trim();

    // Validation des champs obligatoires
    if (nom.isEmpty() || prenoms.isEmpty() || telephone.isEmpty()) {
        Toast.makeText(this, "Veuillez remplir tous les champs obligatoires",
                      Toast.LENGTH_SHORT).show();
        return;
    }

    // Validation du téléphone
    if (!isValidPhoneNumber(telephone)) {
        Toast.makeText(this, "Numéro de téléphone invalide",
                      Toast.LENGTH_SHORT).show();
        return;
    }

    // Validation de l'email si renseigné
    if (!email.isEmpty() && !isValidEmail(email)) {
        Toast.makeText(this, "Adresse email invalide",
                      Toast.LENGTH_SHORT).show();
        return;
    }

    // Création du contact
    Contact contact = new Contact(
        UUID.randomUUID().toString(),
        nom,
        prenoms,
        email,
        telephone,
        lieuHabitation,
        lienMap
    );

    contactManager.addContact(contact);
    Toast.makeText(this, "Contact enregistré", Toast.LENGTH_SHORT).show();
    finish();
}

COMMENT ÇA MARCHE:
1. Récupère le texte de tous les champs
2. trim() supprime les espaces au début et à la fin
3. Vérifie que les champs obligatoires sont remplis
4. Valide le format du téléphone
5. Valide le format de l'email s'il est renseigné
6. Crée un nouveau Contact avec un ID unique (UUID)
7. Ajoute le contact via le ContactManager
8. Affiche un message de confirmation
9. finish() ferme l'activité et retourne à MainActivity

MÉTHODE: isValidPhoneNumber (Valider un numéro)
------------------------------------------------
private boolean isValidPhoneNumber(String phone) {
    return phone.matches("^[+]?[0-9]{8,15}$");
}

COMMENT ÇA MARCHE:
→ Regex (expression régulière):
  - ^ = début de la chaîne
  - [+]? = un "+" optionnel
  - [0-9]{8,15} = entre 8 et 15 chiffres
  - $ = fin de la chaîne
→ Retourne true si le numéro est valide, false sinon

MÉTHODE: isValidEmail (Valider un email)
-----------------------------------------
private boolean isValidEmail(String email) {
    return Patterns.EMAIL_ADDRESS.matcher(email).matches();
}

→ Utilise le pattern EMAIL_ADDRESS d'Android pour vérifier le format

MÉTHODE: onSupportNavigateUp (Bouton retour de l'ActionBar)
------------------------------------------------------------
public boolean onSupportNavigateUp() {
    finish();
    return true;
}

→ Appelée quand on clique sur la flèche retour en haut
→ Ferme l'activité


================================================================================
CONCEPTS IMPORTANTS UTILISÉS DANS LE CODE
================================================================================

1. VIEWBINDING:
---------------
→ Remplace findViewById()
→ Plus sûr et plus rapide
→ binding.nomDuChamp pour accéder aux vues

2. LAMBDA EXPRESSIONS:
----------------------
→ Syntaxe: (paramètres) -> { code }
→ Exemple: v -> doSomething()
→ Remplace les classes anonymes

3. INTERFACES:
--------------
→ Définissent un contrat (méthodes à implémenter)
→ Exemple: OnContactActionListener
→ Permettent le découplage du code

4. RECYCLERVIEW:
----------------
→ Affichage de listes optimisé
→ Utilise un Adapter pour lier données et vues
→ Recycle les vues pour économiser la mémoire

5. SHAREDPREFERENCES:
---------------------
→ Stockage clé-valeur persistant
→ Parfait pour de petites données
→ Survit à la fermeture de l'app

6. GSON:
--------
→ Convertit objets Java ↔ JSON
→ toJson() = objet vers JSON
→ fromJson() = JSON vers objet

7. PARCELABLE:
--------------
→ Permet de passer des objets entre activités
→ Plus rapide que Serializable
→ Nécessite writeToParcel() et un constructeur spécial

8. PERMISSIONS:
---------------
→ Demandées à l'exécution (runtime)
→ checkSelfPermission() pour vérifier
→ requestPermissions() pour demander
→ onRequestPermissionsResult() pour la réponse

9. INTENTS:
-----------
→ Pour naviguer entre activités
→ Ou pour lancer d'autres apps (téléphone, SMS, Maps)
→ ACTION_CALL, ACTION_SENDTO, ACTION_VIEW

10. TOAST:
----------
→ Petits messages temporaires
→ LENGTH_SHORT = 2 secondes
→ LENGTH_LONG = 3.5 secondes


================================================================================
FIN DU RÉSUMÉ
================================================================================

Ce document explique comment tout le code Java est structuré et comment il
fonctionne. Vous pouvez vous y référer pour comprendre chaque partie du projet.
